package services_test

import (
	"context"
	"errors"
	"fmt"
	"strings"
	"testing"

	"github.com/abrezinsky/derbyvote/internal/logger"
	"github.com/abrezinsky/derbyvote/internal/repository/mock"
	"github.com/abrezinsky/derbyvote/internal/services"
	"github.com/abrezinsky/derbyvote/internal/testutil"
)

func TestVoterService_CreateVoter_AllFields(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	voter := services.Voter{
		Name:      "John Doe",
		Email:     "john@example.com",
		VoterType: "judge",
		QRCode:    "TEST-QR1",
		Notes:     "Test notes",
	}

	id, qrCode, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}
	if id <= 0 {
		t.Errorf("expected positive ID, got %d", id)
	}
	if qrCode != "TEST-QR1" {
		t.Errorf("expected QR code 'TEST-QR1', got %q", qrCode)
	}

	// Verify voter was created
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 1 {
		t.Fatalf("expected 1 voter, got %d", len(voters))
	}

	v := voters[0]
	if v["name"] != "John Doe" {
		t.Errorf("expected name 'John Doe', got %v", v["name"])
	}
	if v["email"] != "john@example.com" {
		t.Errorf("expected email 'john@example.com', got %v", v["email"])
	}
	if v["voter_type"] != "judge" {
		t.Errorf("expected voter_type 'judge', got %v", v["voter_type"])
	}
	if v["qr_code"] != "TEST-QR1" {
		t.Errorf("expected qr_code 'TEST-QR1', got %v", v["qr_code"])
	}
	if v["notes"] != "Test notes" {
		t.Errorf("expected notes 'Test notes', got %v", v["notes"])
	}
}

func TestVoterService_CreateVoter_AutoGeneratedQRCode(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	voter := services.Voter{
		Name:  "Jane Doe",
		Email: "jane@example.com",
	}

	id, qrCode, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}
	if id <= 0 {
		t.Errorf("expected positive ID, got %d", id)
	}

	// QR code should be auto-generated in format XX-YYY
	if qrCode == "" {
		t.Error("expected auto-generated QR code, got empty string")
	}
	if !strings.Contains(qrCode, "-") {
		t.Errorf("expected QR code format XX-YYY, got %q", qrCode)
	}
	parts := strings.Split(qrCode, "-")
	if len(parts) != 2 {
		t.Errorf("expected QR code with exactly one hyphen, got %q", qrCode)
	}
	if len(parts[0]) != 2 || len(parts[1]) != 3 {
		t.Errorf("expected QR code format XX-YYY (2 chars - 3 chars), got %q", qrCode)
	}
}

func TestVoterService_CreateVoter_DefaultVoterType(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	voter := services.Voter{
		Name:   "Bob Smith",
		QRCode: "TEST-QR2",
	}

	_, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}

	// Verify default voter_type is "general"
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 1 {
		t.Fatalf("expected 1 voter, got %d", len(voters))
	}
	if voters[0]["voter_type"] != "general" {
		t.Errorf("expected default voter_type 'general', got %v", voters[0]["voter_type"])
	}
}

func TestVoterService_UpdateVoter(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Create a voter first
	voter := services.Voter{
		Name:      "Original Name",
		Email:     "original@example.com",
		VoterType: "general",
		QRCode:    "TEST-QR3",
	}
	id, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}

	// Update the voter
	updatedVoter := services.Voter{
		ID:        int(id),
		Name:      "Updated Name",
		Email:     "updated@example.com",
		VoterType: "judge",
		Notes:     "Updated notes",
	}
	err = svc.UpdateVoter(ctx, updatedVoter)
	if err != nil {
		t.Fatalf("UpdateVoter failed: %v", err)
	}

	// Verify the update
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 1 {
		t.Fatalf("expected 1 voter, got %d", len(voters))
	}

	v := voters[0]
	if v["name"] != "Updated Name" {
		t.Errorf("expected name 'Updated Name', got %v", v["name"])
	}
	if v["email"] != "updated@example.com" {
		t.Errorf("expected email 'updated@example.com', got %v", v["email"])
	}
	if v["voter_type"] != "judge" {
		t.Errorf("expected voter_type 'judge', got %v", v["voter_type"])
	}
	if v["notes"] != "Updated notes" {
		t.Errorf("expected notes 'Updated notes', got %v", v["notes"])
	}
}

func TestVoterService_DeleteVoter(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Create a voter
	voter := services.Voter{
		Name:   "To Be Deleted",
		QRCode: "TEST-QR4",
	}
	id, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}

	// Verify voter exists
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 1 {
		t.Fatalf("expected 1 voter before delete, got %d", len(voters))
	}

	// Delete the voter
	err = svc.DeleteVoter(ctx, int(id))
	if err != nil {
		t.Fatalf("DeleteVoter failed: %v", err)
	}

	// Verify voter is gone
	voters, err = svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 0 {
		t.Errorf("expected 0 voters after delete, got %d", len(voters))
	}
}

func TestVoterService_ListVoters_Empty(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 0 {
		t.Errorf("expected 0 voters in empty database, got %d", len(voters))
	}
}

func TestVoterService_ListVoters_WithData(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Create multiple voters
	voters := []services.Voter{
		{Name: "Voter One", QRCode: "QR-001"},
		{Name: "Voter Two", QRCode: "QR-002"},
		{Name: "Voter Three", QRCode: "QR-003"},
	}
	for _, v := range voters {
		_, _, err := svc.CreateVoter(ctx, v)
		if err != nil {
			t.Fatalf("CreateVoter failed: %v", err)
		}
	}

	// List voters
	result, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(result) != 3 {
		t.Errorf("expected 3 voters, got %d", len(result))
	}
}

func TestVoterService_GenerateQRCodes_ValidCount(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Generate 5 QR codes
	qrCodes, err := svc.GenerateQRCodes(ctx, 5)
	if err != nil {
		t.Fatalf("GenerateQRCodes failed: %v", err)
	}
	if len(qrCodes) != 5 {
		t.Errorf("expected 5 QR codes, got %d", len(qrCodes))
	}

	// Verify all QR codes are in correct format XX-YYY
	for i, qr := range qrCodes {
		if !strings.Contains(qr, "-") {
			t.Errorf("QR code %d: expected format XX-YYY, got %q", i, qr)
		}
		parts := strings.Split(qr, "-")
		if len(parts) != 2 || len(parts[0]) != 2 || len(parts[1]) != 3 {
			t.Errorf("QR code %d: expected format XX-YYY, got %q", i, qr)
		}
	}

	// Verify voters were created in the database
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 5 {
		t.Errorf("expected 5 voters created, got %d", len(voters))
	}
}

func TestVoterService_GenerateQRCodes_BoundaryValues(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Test minimum valid count (1)
	qrCodes, err := svc.GenerateQRCodes(ctx, 1)
	if err != nil {
		t.Fatalf("GenerateQRCodes(1) failed: %v", err)
	}
	if len(qrCodes) != 1 {
		t.Errorf("expected 1 QR code, got %d", len(qrCodes))
	}
}

func TestVoterService_GenerateQRCodes_MaxBoundary(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Test maximum valid count (200)
	qrCodes, err := svc.GenerateQRCodes(ctx, 200)
	if err != nil {
		t.Fatalf("GenerateQRCodes(200) failed: %v", err)
	}
	if len(qrCodes) != 200 {
		t.Errorf("expected 200 QR codes, got %d", len(qrCodes))
	}
}

func TestVoterService_GenerateQRCodes_InvalidCount_Zero(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	_, err := svc.GenerateQRCodes(ctx, 0)
	if err == nil {
		t.Error("expected error for count=0, got nil")
	}
	if err != services.ErrInvalidQRCount {
		t.Errorf("expected ErrInvalidQRCount, got %v", err)
	}
}

func TestVoterService_GenerateQRCodes_InvalidCount_Negative(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	_, err := svc.GenerateQRCodes(ctx, -1)
	if err == nil {
		t.Error("expected error for count=-1, got nil")
	}
	if err != services.ErrInvalidQRCount {
		t.Errorf("expected ErrInvalidQRCount, got %v", err)
	}

	_, err = svc.GenerateQRCodes(ctx, -100)
	if err == nil {
		t.Error("expected error for count=-100, got nil")
	}
	if err != services.ErrInvalidQRCount {
		t.Errorf("expected ErrInvalidQRCount, got %v", err)
	}
}

func TestVoterService_GenerateQRCodes_InvalidCount_TooHigh(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	_, err := svc.GenerateQRCodes(ctx, 201)
	if err == nil {
		t.Error("expected error for count=201, got nil")
	}
	if err != services.ErrInvalidQRCount {
		t.Errorf("expected ErrInvalidQRCount, got %v", err)
	}

	_, err = svc.GenerateQRCodes(ctx, 1000)
	if err == nil {
		t.Error("expected error for count=1000, got nil")
	}
	if err != services.ErrInvalidQRCount {
		t.Errorf("expected ErrInvalidQRCount, got %v", err)
	}
}

func TestVoterService_GenerateQRImage_ExistingVoter(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Set base_url (required for QR code generation)
	if err := settingsSvc.SetBaseURL(ctx, "http://test.local:8080"); err != nil {
		t.Fatalf("SetBaseURL failed: %v", err)
	}

	// Create a voter
	voter := services.Voter{
		Name:   "QR Image Test",
		QRCode: "TEST-IMG",
	}
	id, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}

	// Generate QR image
	imageData, err := svc.GenerateQRImage(ctx, int(id))
	if err != nil {
		t.Fatalf("GenerateQRImage failed: %v", err)
	}
	if len(imageData) == 0 {
		t.Error("expected non-empty image data")
	}

	// Verify it's a PNG (PNG magic bytes)
	if len(imageData) < 8 {
		t.Fatal("image data too short to be a valid PNG")
	}
	pngSignature := []byte{0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A}
	for i, b := range pngSignature {
		if imageData[i] != b {
			t.Errorf("expected PNG signature byte %d to be %x, got %x", i, b, imageData[i])
		}
	}
}

func TestVoterService_GenerateQRImage_NonExistentVoter(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Try to generate QR image for non-existent voter
	_, err := svc.GenerateQRImage(ctx, 99999)
	if err == nil {
		t.Error("expected error for non-existent voter, got nil")
	}
	if !strings.Contains(err.Error(), "voter not found") {
		t.Errorf("expected 'voter not found' error, got %v", err)
	}
}

func TestVoterService_GenerateQRImage_WithCustomBaseURL(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Set a custom base URL
	customURL := "https://voting.example.com"
	err := settingsSvc.SetBaseURL(ctx, customURL)
	if err != nil {
		t.Fatalf("SetBaseURL failed: %v", err)
	}

	// Create a voter
	voter := services.Voter{
		Name:   "Custom URL Test",
		QRCode: "CUSTOM-1",
	}
	id, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}

	// Generate QR image - should use custom base URL internally
	imageData, err := svc.GenerateQRImage(ctx, int(id))
	if err != nil {
		t.Fatalf("GenerateQRImage failed: %v", err)
	}
	if len(imageData) == 0 {
		t.Error("expected non-empty image data")
	}
}

func TestVoterService_CreateVoter_WithCarID(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Create a car first (required due to foreign key constraint)
	_ = repo.CreateCar(ctx, "42", "Test Racer", "Test Car", "")
	cars, _ := repo.ListCars(ctx)
	carID := cars[0].ID

	voter := services.Voter{
		CarID:  &carID,
		Name:   "Car Owner",
		QRCode: "CAR-001",
	}

	id, _, err := svc.CreateVoter(ctx, voter)
	if err != nil {
		t.Fatalf("CreateVoter failed: %v", err)
	}
	if id <= 0 {
		t.Errorf("expected positive ID, got %d", id)
	}

	// Verify voter was created with car_id
	voters, err := svc.ListVoters(ctx)
	if err != nil {
		t.Fatalf("ListVoters failed: %v", err)
	}
	if len(voters) != 1 {
		t.Fatalf("expected 1 voter, got %d", len(voters))
	}

	// Note: car_id may be stored but the relationship depends on whether
	// the car exists in the database
	if voters[0]["qr_code"] != "CAR-001" {
		t.Errorf("expected qr_code 'CAR-001', got %v", voters[0]["qr_code"])
	}
}

func TestVoterService_GenerateQRCodes_UniqueQRCodes(t *testing.T) {
	repo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, repo)
	svc := services.NewVoterService(log, repo, settingsSvc)
	ctx := context.Background()

	// Generate multiple QR codes
	qrCodes, err := svc.GenerateQRCodes(ctx, 50)
	if err != nil {
		t.Fatalf("GenerateQRCodes failed: %v", err)
	}

	// Verify all QR codes are unique
	seen := make(map[string]bool)
	for _, qr := range qrCodes {
		if seen[qr] {
			t.Errorf("duplicate QR code found: %s", qr)
		}
		seen[qr] = true
	}
}

func TestGenerateReadableCode_Format(t *testing.T) {
	// Test that GenerateReadableCode produces consistent format
	testSeeds := []string{
		"test-seed-1",
		"test-seed-2",
		"voter-12345-John",
		"bulk-1234567890-0",
	}

	for _, seed := range testSeeds {
		code := services.GenerateReadableCode(seed)

		// Check format XX-YYY
		if !strings.Contains(code, "-") {
			t.Errorf("seed %q: expected format XX-YYY, got %q", seed, code)
			continue
		}

		parts := strings.Split(code, "-")
		if len(parts) != 2 {
			t.Errorf("seed %q: expected exactly one hyphen, got %q", seed, code)
			continue
		}
		if len(parts[0]) != 2 {
			t.Errorf("seed %q: expected 2 chars before hyphen, got %d in %q", seed, len(parts[0]), code)
		}
		if len(parts[1]) != 3 {
			t.Errorf("seed %q: expected 3 chars after hyphen, got %d in %q", seed, len(parts[1]), code)
		}

		// Check that no ambiguous characters are used (O, 0, I, 1, L)
		ambiguous := "O0I1L"
		for _, char := range code {
			if strings.ContainsRune(ambiguous, char) && char != '-' {
				t.Errorf("seed %q: code %q contains ambiguous character %c", seed, code, char)
			}
		}
	}
}

func TestGenerateReadableCode_Deterministic(t *testing.T) {
	// Test that the same seed produces the same code
	seed := "deterministic-test-seed"

	code1 := services.GenerateReadableCode(seed)
	code2 := services.GenerateReadableCode(seed)

	if code1 != code2 {
		t.Errorf("expected same code for same seed, got %q and %q", code1, code2)
	}
}

func TestGenerateReadableCode_DifferentSeeds(t *testing.T) {
	// Test that different seeds produce different codes
	seed1 := "unique-seed-one"
	seed2 := "unique-seed-two"

	code1 := services.GenerateReadableCode(seed1)
	code2 := services.GenerateReadableCode(seed2)

	if code1 == code2 {
		t.Errorf("expected different codes for different seeds, both got %q", code1)
	}
}

// ===== Error Path Tests =====

func TestVoterService_GenerateQRCodes_InsertVoterError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	mockRepo.InsertVoterIgnoreError = errors.New("database error")

	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()
	// Should still succeed even if some InsertVoterIgnore calls fail (errors are logged but not returned)
	qrCodes, err := svc.GenerateQRCodes(ctx, 5)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if len(qrCodes) != 5 {
		t.Errorf("expected 5 QR codes, got %d", len(qrCodes))
	}
}

func TestVoterService_GenerateQRImage_GetVoterQRCodeError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	mockRepo.GetVoterQRCodeError = errors.New("database error")

	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()
	_, err := svc.GenerateQRImage(ctx, 1)
	if err == nil {
		t.Fatal("expected error when GetVoterQRCode fails, got nil")
	}
}

func TestVoterService_GenerateQRImage_GetBaseURLError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)

	log := logger.New()
	settingsSvc := services.NewSettingsService(log, mockRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()

	// First create a voter so GetVoterQRCode succeeds
	voterID, _ := realRepo.CreateVoter(ctx, "TEST-QR")

	// Then make GetSetting fail (which GetBaseURL uses)
	mockRepo.GetSettingError = errors.New("database error")

	_, err := svc.GenerateQRImage(ctx, voterID)
	if err == nil {
		t.Fatal("expected error when GetBaseURL fails, got nil")
	}
}

func TestVoterService_GenerateQRImage_BaseURLNotConfigured(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Create a voter
	voterID, _ := realRepo.CreateVoter(ctx, "TEST-QR")

	// Don't set base_url - it should error
	_, err := svc.GenerateQRImage(ctx, voterID)
	if err == nil {
		t.Fatal("expected error when base_url not configured, got nil")
	}
}

func TestVoterService_GenerateUniqueCode_Success(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting (disable required registered QR)
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	code, err := svc.GenerateUniqueCode(ctx)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	if code == "" {
		t.Fatal("expected non-empty code")
	}

	// Code should be 8 hex characters
	if len(code) != 8 {
		t.Errorf("expected code length 8, got %d", len(code))
	}
}

func TestVoterService_GenerateUniqueCode_OpenVotingDisabled(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Disable open voting (require registered QR)
	settingsSvc.SetRequireRegisteredQR(ctx, true)

	_, err := svc.GenerateUniqueCode(ctx)
	if err != services.ErrOpenVotingDisabled {
		t.Errorf("expected ErrOpenVotingDisabled, got: %v", err)
	}
}

func TestVoterService_GenerateUniqueCode_RetriesOnDuplicate(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Generate first code
	code1, err := svc.GenerateUniqueCode(ctx)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	// Create a voter with that code so it exists in DB
	realRepo.CreateVoter(ctx, code1)

	// Generate another code - should be different
	code2, err := svc.GenerateUniqueCode(ctx)
	if err != nil {
		t.Fatalf("expected no error on retry, got: %v", err)
	}

	if code1 == code2 {
		t.Error("expected different codes after retry")
	}
}

func TestVoterService_GenerateDynamicQRImage_Success(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Set base URL
	settingsSvc.SetBaseURL(ctx, "http://localhost:8080")

	png, err := svc.GenerateDynamicQRImage(ctx)
	if err != nil {
		t.Fatalf("expected no error, got: %v", err)
	}

	if len(png) == 0 {
		t.Fatal("expected non-empty PNG data")
	}

	// PNG files start with \x89PNG
	if len(png) < 4 || png[0] != 0x89 || png[1] != 0x50 || png[2] != 0x4E || png[3] != 0x47 {
		t.Error("expected valid PNG data")
	}
}

func TestVoterService_GenerateDynamicQRImage_OpenVotingDisabled(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Disable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, true)

	// Set base URL
	settingsSvc.SetBaseURL(ctx, "http://localhost:8080")

	_, err := svc.GenerateDynamicQRImage(ctx)
	if err != services.ErrOpenVotingDisabled {
		t.Errorf("expected ErrOpenVotingDisabled, got: %v", err)
	}
}

func TestVoterService_GenerateDynamicQRImage_BaseURLNotConfigured(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Don't set base_url
	_, err := svc.GenerateDynamicQRImage(ctx)
	if err == nil {
		t.Fatal("expected error when base_url not configured, got nil")
	}
}
func TestVoterService_GenerateUniqueCode_SettingsError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, mockRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()

	// Inject error when checking settings
	mockRepo.GetSettingError = fmt.Errorf("database connection lost")

	_, err := svc.GenerateUniqueCode(ctx)
	if err == nil {
		t.Fatal("expected error when settings check fails, got nil")
	}

	if !strings.Contains(err.Error(), "error checking settings") {
		t.Errorf("expected 'error checking settings' in error message, got: %v", err)
	}
}

func TestVoterService_GenerateUniqueCode_DatabaseError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, mockRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Inject database error when checking code uniqueness
	mockRepo.GetVoterByQRError = fmt.Errorf("database connection lost")

	_, err := svc.GenerateUniqueCode(ctx)
	if err == nil {
		t.Fatal("expected error when database check fails, got nil")
	}

	if !strings.Contains(err.Error(), "error checking code uniqueness") {
		t.Errorf("expected 'error checking code uniqueness' in error message, got: %v", err)
	}
}

func TestVoterService_GenerateDynamicQRImage_SettingsError(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, mockRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()

	// Inject error when checking settings
	mockRepo.GetSettingError = fmt.Errorf("database connection lost")

	_, err := svc.GenerateDynamicQRImage(ctx)
	if err == nil {
		t.Fatal("expected error when settings check fails, got nil")
	}

	if !strings.Contains(err.Error(), "error checking settings") {
		t.Errorf("expected 'error checking settings' in error message, got: %v", err)
	}
}

func TestVoterService_GenerateUniqueCode_MaxRetriesExceeded(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, mockRepo)
	svc := services.NewVoterService(log, mockRepo, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Pre-populate many voters to increase collision probability
	// This won't reliably trigger max retries, but will test the logic exists
	for i := 0; i < 1000; i++ {
		code := fmt.Sprintf("%08x", i)
		realRepo.CreateVoter(ctx, code)
	}

	// Try to generate a code - should still succeed since hex space is large
	// This tests that the retry logic works even with many existing codes
	code, err := svc.GenerateUniqueCode(ctx)
	if err != nil {
		// If we actually hit max retries with random generation, that's extremely unlikely
		// but the error message should be correct
		if !strings.Contains(err.Error(), "failed to generate unique code after") {
			t.Errorf("expected 'failed to generate unique code after' in error, got: %v", err)
		}
		return
	}

	// Most likely case: code was generated successfully
	if code == "" {
		t.Fatal("expected non-empty code")
	}
}

// alwaysExistsRepo wraps a mock repo to simulate all codes already exist
type alwaysExistsRepo struct {
	*mock.Repository
}

func (m *alwaysExistsRepo) GetVoterByQR(ctx context.Context, qrCode string) (int, error) {
	// Always return a voter ID (simulating code exists)
	return 1, nil
}

func TestVoterService_GenerateUniqueCode_MaxRetriesExceeded_Forced(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	mockRepo := mock.NewRepository(realRepo)
	alwaysExists := &alwaysExistsRepo{Repository: mockRepo}
	
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo) // Use real repo for settings
	svc := services.NewVoterService(log, alwaysExists, settingsSvc)

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Try to generate a code - should fail after max retries since all codes "exist"
	_, err := svc.GenerateUniqueCode(ctx)
	if err == nil {
		t.Fatal("expected error when max retries exceeded, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate unique code after") {
		t.Errorf("expected 'failed to generate unique code after' in error, got: %v", err)
	}
}

// failingReader always returns an error
type failingReader struct{}

func (f failingReader) Read(p []byte) (n int, err error) {
	return 0, fmt.Errorf("random number generator failure")
}

func TestVoterService_GenerateUniqueCode_RandReadFailure(t *testing.T) {
	realRepo := testutil.NewTestRepository(t)
	log := logger.New()
	settingsSvc := services.NewSettingsService(log, realRepo)
	svc := services.NewVoterService(log, realRepo, settingsSvc)

	// Inject failing random reader
	svc.SetRandReader(failingReader{})

	ctx := context.Background()

	// Enable open voting
	settingsSvc.SetRequireRegisteredQR(ctx, false)

	// Try to generate a code - should fail due to rand.Read error
	_, err := svc.GenerateUniqueCode(ctx)
	if err == nil {
		t.Fatal("expected error when rand.Read fails, got nil")
	}

	if !strings.Contains(err.Error(), "failed to generate random code") {
		t.Errorf("expected 'failed to generate random code' in error, got: %v", err)
	}
}
